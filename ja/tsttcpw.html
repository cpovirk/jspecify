

<!DOCTYPE html>
<html class="writer-html5" lang="ja" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>The Simplest(?) Thing That Could Possibly Work for subtyping &mdash; JSpecify  ドキュメント</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script src="_static/translations.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="検索" href="search.html" />
    <link rel="prev" title="JSpecify: 静的解析のための標準化されたJavaアノテーション" href="index.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> JSpecify
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">The Simplest(?) Thing That Could Possibly Work for subtyping</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#references-to-concepts-defined-by-this-spec">References to concepts defined by this spec</a></li>
<li class="toctree-l2"><a class="reference internal" href="#additional-nullness">Additional nullness</a></li>
<li class="toctree-l2"><a class="reference internal" href="#augmented-type">Augmented type</a></li>
<li class="toctree-l2"><a class="reference internal" href="#null-aware-context">Null-aware context</a></li>
<li class="toctree-l2"><a class="reference internal" href="#augmented-type-of-a-type-usage-in-code">Augmented type of a type usage in code</a></li>
<li class="toctree-l2"><a class="reference internal" href="#augmented-type-of-an-intersection-type">Augmented type of an intersection type</a></li>
<li class="toctree-l2"><a class="reference internal" href="#unioning-an-augmented-type-with-an-additional-nullness">Unioning an augmented type with an additional nullness</a></li>
<li class="toctree-l2"><a class="reference internal" href="#bound-of-an-unbounded-wildcard">Bound of an “unbounded” wildcard</a></li>
<li class="toctree-l2"><a class="reference internal" href="#bound-of-an-object-bounded-type-parameter">Bound of an <code class="docutils literal notranslate"><span class="pre">Object</span></code>-bounded type parameter</a></li>
<li class="toctree-l2"><a class="reference internal" href="#substitution">Substitution</a></li>
<li class="toctree-l2"><a class="reference internal" href="#augmented-null-types">Augmented null types</a></li>
<li class="toctree-l2"><a class="reference internal" href="#the-least-convenient-world-and-the-most-convenient-world">The least convenient world and the most convenient world</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#propagating-the-most-least-convenient-world">Propagating the most/least convenient world</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#same-type">Same type</a></li>
<li class="toctree-l2"><a class="reference internal" href="#subtyping">Subtyping</a></li>
<li class="toctree-l2"><a class="reference internal" href="#nullness-delegating-subtyping-rules-for-java">Nullness-delegating subtyping rules for Java</a></li>
<li class="toctree-l2"><a class="reference internal" href="#nullness-subtyping">Nullness subtyping</a></li>
<li class="toctree-l2"><a class="reference internal" href="#null-inclusive-under-every-parameterization">Null-inclusive under every parameterization</a></li>
<li class="toctree-l2"><a class="reference internal" href="#null-exclusive-under-every-parameterization">Null-exclusive under every parameterization</a></li>
<li class="toctree-l2"><a class="reference internal" href="#nullness-subtype-establishing-path">Nullness-subtype-establishing path</a></li>
<li class="toctree-l2"><a class="reference internal" href="#nullness-subtype-establishing-direct-supertype-edges">Nullness-subtype-establishing direct-supertype edges</a></li>
<li class="toctree-l2"><a class="reference internal" href="#containment">Containment</a></li>
<li class="toctree-l2"><a class="reference internal" href="#capture-conversion">Capture conversion</a></li>
</ul>
</li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">JSpecify</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>The Simplest(?) Thing That Could Possibly Work for subtyping</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/tsttcpw.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="the-simplest-thing-that-could-possibly-work-for-subtyping">
<h1>The Simplest(?) Thing That Could Possibly Work for subtyping<a class="headerlink" href="#the-simplest-thing-that-could-possibly-work-for-subtyping" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p><strong>This is not “the JSpecify spec.” This is an initial attempt to
formally specify only a subset of the rules we’ll need for a subset of
features we wish to cover. Additionally, it deviates from some of our
current working decisions in an effort to remain simple.</strong></p>
<blockquote>
<div><p class="rubric" id="high-level-overview">High-level overview</p>
<p>It may be that some people will use this doc to guide their
implementations in the near future. Please don’t hesitate to let
cpovirk know of any confusing bits.</p>
<p>I should probably preemptively clarify at least one thing. In this
doc, I have tried to distinguish explicitly between 3 “kinds of
nullability” of a given type usage. Each kind is derived (at least in
part) from the previous:</p>
<ol class="arabic simple">
<li><p>What annotation (if any) appears directly on that type usage?</p></li>
<li><p>What is the <a class="reference external" href="#additional-nullness">additional nullness</a> of that
type usage?</p></li>
<li><p>For that type usage…</p>
<ul class="simple">
<li><p>Is it safe to assume that is not <code class="docutils literal notranslate"><span class="pre">null</span></code>?</p></li>
<li><p>Is it safe to put a <code class="docutils literal notranslate"><span class="pre">null</span></code> into it?</p></li>
<li><p>neither (as in “parametric nullness”)</p></li>
<li><p>both (as in “unspecified nullness” in “lenient mode”)</p></li>
</ul>
</li>
</ol>
</div></blockquote>
<div class="section" id="references-to-concepts-defined-by-this-spec">
<span id="concept-references"></span><h2>References to concepts defined by this spec<a class="headerlink" href="#references-to-concepts-defined-by-this-spec" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>When a rule in this spec refers to any concept that is defined in this
spec (for example, <a class="reference external" href="#substitution">substitution</a> or
<a class="reference external" href="#containment">containment</a>), apply this spec’s definition (as
opposed to other definitions, such as the ones in the JLS).</p>
<p>Additionally, when a rule in this spec refers to a JLS rule that in turn
refers to a concept that is defined in this spec, likewise apply this
spec’s definition.</p>
<p>In particular, when a JLS rule refers to types, apply this spec’s
definition of <a class="reference external" href="#augmented-type">augmented types</a> (as oppposed to
<a class="reference external" href="https://docs.google.com/document/d/1KQrBxwaVIPIac_6SCf--w-vZBeHkTvtaqPSU_icIccc/edit#bookmark=kix.k81vs7t5p45i">base
types</a>).</p>
</div>
<div class="section" id="additional-nullness">
<h2>Additional nullness<a class="headerlink" href="#additional-nullness" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>An additional nullness is one of 3 values:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">UNION_NULL</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CODE_NOT_NULLNESS_AWARE</span></code></p></li>
</ul>
<blockquote>
<div><p>The distinction among these 3 values is similar to the distinction
among the Kotlin types <code class="docutils literal notranslate"><span class="pre">Foo?</span></code>, <code class="docutils literal notranslate"><span class="pre">Foo</span></code>, and <code class="docutils literal notranslate"><span class="pre">Foo!</span></code>, respectively.</p>
</div></blockquote>
</div>
<div class="section" id="augmented-type">
<h2>Augmented type<a class="headerlink" href="#augmented-type" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>An augmented type consists of a <a class="reference external" href="https://docs.google.com/document/d/1KQrBxwaVIPIac_6SCf--w-vZBeHkTvtaqPSU_icIccc/edit#bookmark=kix.k81vs7t5p45i">base
type</a>
and an <a class="reference external" href="#additional-nullness">additional nullness</a> corresponding to
<em>each</em> of its <a class="reference external" href="https://docs.google.com/document/d/1KQrBxwaVIPIac_6SCf--w-vZBeHkTvtaqPSU_icIccc/edit#bookmark=kix.g7gl9fwq1tt5">type
components</a>.</p>
<blockquote>
<div><p>This differs from our current <a class="reference external" href="https://docs.google.com/document/d/1KQrBxwaVIPIac_6SCf--w-vZBeHkTvtaqPSU_icIccc/edit#bookmark=id.367l48xhsikk">glossary
definition</a>,
which is written in terms of a “nullness” for each component, not an
“additional nullness.” Still, the glossary’s concept of the
“nullness” of a type is derivable from the type’s additional
nullness. Notably, the glossary’s “nullable” type is our <a class="reference external" href="#multiple-worlds">least
convenient world’s</a>’s <a class="reference external" href="#null-inclusive-under-every-parameterization">null-inclusive under
every
parameterization</a>,
and the glossary’s “non-nullable” type is our least convenient
world’s <a class="reference external" href="#null-exclusive-under-every-parameterization">null-exclusive under every
parameterization</a>.</p>
</div></blockquote>
<p>For our purposes, base types (and thus augmented types) include not just
class and interface types, array types, and type variables but also
intersection types and the null type. This is true even though the JLS
sometimes does not supply rules for intersection types and sometimes has
separate rules for the null type.</p>
<p>The goal of this spec is to define rules for augmented types compatible
with those that the JLS defines for base types.</p>
<blockquote>
<div><p>In almost all cases, this spec agrees with the JLS’s rules when
specifying what <em>base</em> types appear in a piece of code. It makes an
exception for <a class="reference external" href="#unbounded-wildcard">“Bound of an unbounded
wildcard,”</a> for which it specifies a bound of
<code class="docutils literal notranslate"><span class="pre">Object</span></code> that the JLS does not specify.</p>
</div></blockquote>
<p>When this spec uses capital letters, they refer to augmented types
(unless otherwise noted). This is in contrast to the JLS, which
typically uses them to refer to base types.</p>
<p>When this spec refers to “the additional nullness of” a type <code class="docutils literal notranslate"><span class="pre">T</span></code>, it
refers specifically to the additional nullness of the type component
that is the entire type <code class="docutils literal notranslate"><span class="pre">T</span></code>, without reference to the additional
nullness of any other type components of <code class="docutils literal notranslate"><span class="pre">T</span></code>.</p>
<blockquote>
<div><p>For example, the additional nullness of <code class="docutils literal notranslate"><span class="pre">List&lt;&#64;Nullable</span> <span class="pre">Object&gt;</span></code>
would be <code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code> (at least in a <a class="reference external" href="#null-aware-context">null-aware
context</a>), even though the additional
nullness of its element type <code class="docutils literal notranslate"><span class="pre">Object</span></code> is <code class="docutils literal notranslate"><span class="pre">UNION_NULL</span></code>.</p>
</div></blockquote>
</div>
<div class="section" id="null-aware-context">
<h2>Null-aware context<a class="headerlink" href="#null-aware-context" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>To determine whether a type usage appears in a null-aware context:</p>
<p>Look for an <code class="docutils literal notranslate"><span class="pre">&#64;org.jspecify.annotations.NullAware</span></code> annotation on any of
the containing scopes surrounding the type usage.</p>
<p>Class members are contained by classes, which may be contained by other
class members or classes, and top-level classes are contained by
packages, which may be contained by modules.</p>
<blockquote>
<div><p>This concept of “containing scopes” is different from the concept of
“containing types” described under <a class="reference external" href="#containment">Containment</a>.</p>
</div></blockquote>
<p>If an <code class="docutils literal notranslate"><span class="pre">&#64;org.jspecify.annotations.NullAware</span></code> annotation exists on one
of these scopes, then the type usage is in a null-aware context.
Otherwise, it is not.</p>
</div>
<div class="section" id="augmented-type-of-a-type-usage-in-code">
<span id="augmented-type-of-usage"></span><h2>Augmented type of a type usage in code<a class="headerlink" href="#augmented-type-of-a-type-usage-in-code" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>For most type usages in source code or bytecode on which JSpecify
nullness annotations are structurally valid, this section defines how to
determine their <a class="reference external" href="#augmented-type">augmented types</a>. Note, however,
that rules for specific cases below take precedence over the general
rule here.</p>
<p>Because the JLS already has rules for determining the <a class="reference external" href="https://docs.google.com/document/d/1KQrBxwaVIPIac_6SCf--w-vZBeHkTvtaqPSU_icIccc/edit#bookmark=kix.k81vs7t5p45i">base
type</a>
for a type usage, this section covers only how to determine its
<a class="reference external" href="#additional-nullness">additional nullness</a>.</p>
<p>To determine the additional nullness, apply the following rules in
order. Once one condition is met, skip the remaining conditions.</p>
<ul class="simple">
<li><p>If the type usage is annotated with
<code class="docutils literal notranslate"><span class="pre">&#64;org.jspecify.annotations.Nullable</span></code>, its additional nullness is
<code class="docutils literal notranslate"><span class="pre">UNION_NULL</span></code>.</p></li>
<li><p>If the type usage appears in a <a class="reference external" href="#null-aware-context">null-aware
context</a>, its additional nullness is
<code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code>.</p></li>
<li><p>Its additional nullness is <code class="docutils literal notranslate"><span class="pre">CODE_NOT_NULLNESS_AWARE</span></code>.</p></li>
</ul>
</div>
<div class="section" id="augmented-type-of-an-intersection-type">
<span id="intersection-types"></span><h2>Augmented type of an intersection type<a class="headerlink" href="#augmented-type-of-an-intersection-type" title="このヘッドラインへのパーマリンク">¶</a></h2>
<blockquote>
<div><p>Technically speaking, the JLS does not define syntax for an
intersection type. Instead, it defines a syntax for type parameters
and casts that supports multiple types. Then the intersection type is
derived from those. Intersection types can also arise from operations
like <a class="reference external" href="#capture-conversion">capture conversion</a>. See <a class="reference external" href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.9">JLS
4.9</a>.</p>
<p>One result of all this is that it’s never possible for a programmer
to write an annotation “on an intersection type.”</p>
</div></blockquote>
<p>This spec assigns an <a class="reference external" href="#additional-nullness">additional nullness</a> to
each individual element of an intersection type, following our normal
rules for type usages. It also assigns an additional nullness to the
intersection type as a whole. The additional nullness of the type as a
whole is always <code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code>.</p>
<blockquote>
<div><p>This lets us provide, for every <a class="reference external" href="https://docs.google.com/document/d/1KQrBxwaVIPIac_6SCf--w-vZBeHkTvtaqPSU_icIccc/edit#bookmark=kix.k81vs7t5p45i">base
type</a>,
a rule for computing its <a class="reference external" href="#augmented-type">augmented type</a>. But we
require <code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code> so as to avoid questions like whether “a
<code class="docutils literal notranslate"><span class="pre">UNION_NULL</span></code> intersection type whose members are <code class="docutils literal notranslate"><span class="pre">UNION_NULL</span></code>
<code class="docutils literal notranslate"><span class="pre">Foo</span></code> and <code class="docutils literal notranslate"><span class="pre">UNION_NULL</span></code> <code class="docutils literal notranslate"><span class="pre">Bar</span></code>” is a subtype of “a <code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code>
intersection type with those same members.” Plus, it would be
difficult for tools to output the additional nullness of an
intersection type in a human-readable way.</p>
</div></blockquote>
<blockquote>
<div><p>To avoid ever creating an intersection type with an additional
nullness other than <code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code>, we define special handling for
intersection types under <a class="reference external" href="#unioning">“Unioning an augmented type with an
additional nullness.”</a></p>
</div></blockquote>
</div>
<div class="section" id="unioning-an-augmented-type-with-an-additional-nullness">
<span id="unioning"></span><h2>Unioning an augmented type with an additional nullness<a class="headerlink" href="#unioning-an-augmented-type-with-an-additional-nullness" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Given an <a class="reference external" href="#augmented-type">augmented type</a> (which, again, includes an
<a class="reference external" href="#additional-nullness">additional nullness</a> for the type) and a
second additional nullness, we define a process to union the augmented
type with the second additional nullness:</p>
<p>First, based on the pair of additional nullnesses (the one from the
augmented type and the second additional nullness), compute a “desired
additional nullness.” Do so by applying the following rules in order.
Once one condition is met, skip the remaining conditions.</p>
<ul class="simple">
<li><p>If either additional nullness is <code class="docutils literal notranslate"><span class="pre">UNION_NULL</span></code>, the desired
additional nullness is <code class="docutils literal notranslate"><span class="pre">UNION_NULL</span></code>.</p></li>
<li><p>If either additional nullness is <code class="docutils literal notranslate"><span class="pre">CODE_NOT_NULLNESS_AWARE</span></code>, the
desired additional nullness is <code class="docutils literal notranslate"><span class="pre">CODE_NOT_NULLNESS_AWARE</span></code>.</p></li>
<li><p>The desired additional nullness is <code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code>.</p></li>
</ul>
<p>Then, if the input augmented type is <em>not</em> an intersection type, the
output is the same as the input but with its additional nullness
replaced with the desired additional nullness.</p>
<p>Otherwise, the output is an intersection type. For every element <code class="docutils literal notranslate"><span class="pre">Tᵢ</span></code>
of the input type, the output type has an element that is <code class="docutils literal notranslate"><span class="pre">Tᵢ</span></code> unioned
with the desired additional nullness.</p>
<blockquote>
<div><p>In this case, the desired additional nullness is always equal to the
second additional nullness that was an input to this process. That’s
because the additional nullness <a class="reference external" href="#intersection-types">of the intersection type
itself</a> is defined to always be
<code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code>.</p>
</div></blockquote>
</div>
<div class="section" id="bound-of-an-unbounded-wildcard">
<span id="unbounded-wildcard"></span><h2>Bound of an “unbounded” wildcard<a class="headerlink" href="#bound-of-an-unbounded-wildcard" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>In source, an unbounded wildcard is written as <code class="docutils literal notranslate"><span class="pre">&lt;?&gt;</span></code>. This section
does <strong>not</strong> apply to <code class="docutils literal notranslate"><span class="pre">&lt;?</span> <span class="pre">extends</span> <span class="pre">Object&gt;</span></code>, even though that is often
equivalent to <code class="docutils literal notranslate"><span class="pre">&lt;?&gt;</span></code>. See <a class="reference external" href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.5.1">JLS
4.5.1</a>.</p>
<p>In bytecode, such a wildcard is represented as a wildcard type with an
empty list of upper bounds and an empty list of lower bounds. This
section does <strong>not</strong> apply to a wildcard with any bounds in either list,
even a sole upper bound of <code class="docutils literal notranslate"><span class="pre">Object</span></code>.</p>
<blockquote>
<div><p>For a wildcard with an explicit bound of <code class="docutils literal notranslate"><span class="pre">Object</span></code> (that is,
<code class="docutils literal notranslate"><span class="pre">&lt;?</span> <span class="pre">extends</span> <span class="pre">Object&gt;</span></code>, perhaps with an annotation on <code class="docutils literal notranslate"><span class="pre">Object</span></code>),
instead apply <a class="reference external" href="#augmented-type-of-usage">the normal rules</a> for the
explicit bound type.</p>
</div></blockquote>
<p>If an unbounded wildcard appears in a <a class="reference external" href="#null-aware-context">null-aware
context</a>, then it has a single upper bound whose
<a class="reference external" href="https://docs.google.com/document/d/1KQrBxwaVIPIac_6SCf--w-vZBeHkTvtaqPSU_icIccc/edit#bookmark=kix.k81vs7t5p45i">base
type</a>
is <code class="docutils literal notranslate"><span class="pre">Object</span></code> and whose <a class="reference external" href="#additional-nullness">additional nullness</a>
is <code class="docutils literal notranslate"><span class="pre">UNION_NULL</span></code>.</p>
<p>If an unbounded wildcard appears outside a null-aware context, then it
has a single upper bound whose base type is <code class="docutils literal notranslate"><span class="pre">Object</span></code> and whose
additional nullness is <code class="docutils literal notranslate"><span class="pre">CODE_NOT_NULLNESS_AWARE</span></code>.</p>
<blockquote>
<div><p>In both cases, we specify a bound that does not exist in the source
or bytecode, deviating from the JLS. Because the base type of the
bound is <code class="docutils literal notranslate"><span class="pre">Object</span></code>, this should produce no user-visible differences
except to tools that implement JSpecify nullness analysis.</p>
</div></blockquote>
<p>Whenever a JLS rule refers specifically to <code class="docutils literal notranslate"><span class="pre">&lt;?&gt;</span></code>, disregard it, and
instead apply the rules for <code class="docutils literal notranslate"><span class="pre">&lt;?</span> <span class="pre">extends</span> <span class="pre">T&gt;</span></code>, where <code class="docutils literal notranslate"><span class="pre">T</span></code> has a base
type of <code class="docutils literal notranslate"><span class="pre">Object</span></code> and the additional nullness defined by this section.</p>
</div>
<div class="section" id="bound-of-an-object-bounded-type-parameter">
<span id="object-bounded-type-parameter"></span><h2>Bound of an <code class="docutils literal notranslate"><span class="pre">Object</span></code>-bounded type parameter<a class="headerlink" href="#bound-of-an-object-bounded-type-parameter" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>In source, an <code class="docutils literal notranslate"><span class="pre">Object</span></code>-bounded type parameter can be writen in either
of 2 ways:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;T&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;T</span> <span class="pre">extends</span> <span class="pre">Object&gt;</span></code> with no JSpecify nullness type annotations on
the bound</p></li>
</ul>
<p>See <a class="reference external" href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.4">JLS
4.4</a>.</p>
<p>In bytecode, <code class="docutils literal notranslate"><span class="pre">&lt;T&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">&lt;T</span> <span class="pre">extends</span> <span class="pre">Object&gt;</span></code> are both represented as
a type parameter with only a single upper bound, <code class="docutils literal notranslate"><span class="pre">Object</span></code>, and no
JSpecify nullness type annotations on the bound.</p>
<p>If an <code class="docutils literal notranslate"><span class="pre">Object</span></code>-bounded type parameter appears in a <a class="reference external" href="#null-aware-context">null-aware
context</a>, then its bound has a <a class="reference external" href="https://docs.google.com/document/d/1KQrBxwaVIPIac_6SCf--w-vZBeHkTvtaqPSU_icIccc/edit#bookmark=kix.k81vs7t5p45i">base
type</a>
of <code class="docutils literal notranslate"><span class="pre">Object</span></code> and an <a class="reference external" href="#additional-nullness">additional nullness</a> of
<code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code>.</p>
<blockquote>
<div><p>Note that this gives <code class="docutils literal notranslate"><span class="pre">&lt;T&gt;</span></code> a different bound than <code class="docutils literal notranslate"><span class="pre">&lt;?&gt;</span></code> (though
only in a null-aware context).</p>
</div></blockquote>
<p>If an <code class="docutils literal notranslate"><span class="pre">Object</span></code>-bounded type parameter appears outside a null-aware
context, then its bound has a base type of <code class="docutils literal notranslate"><span class="pre">Object</span></code> and an additional
nullness of <code class="docutils literal notranslate"><span class="pre">CODE_NOT_NULLNESS_AWARE</span></code>.</p>
<blockquote>
<div><p>All these rules match the behavior of <a class="reference external" href="#augmented-type-of-usage">our normal
rules</a> for determining the <a class="reference external" href="#augmented-type">augmented
type</a> of the bound <code class="docutils literal notranslate"><span class="pre">Object</span></code>. The only “special”
part is that we consider the source code <code class="docutils literal notranslate"><span class="pre">&lt;T&gt;</span></code> to have a bound of
<code class="docutils literal notranslate"><span class="pre">Object</span></code>, just as it does when compiled to bytecode.</p>
</div></blockquote>
</div>
<div class="section" id="substitution">
<h2>Substitution<a class="headerlink" href="#substitution" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>To substitute each type argument <code class="docutils literal notranslate"><span class="pre">Aᵢ</span></code> for each corresponding type
parameter <code class="docutils literal notranslate"><span class="pre">Pᵢ</span></code>:</p>
<p>For every type <code class="docutils literal notranslate"><span class="pre">V</span></code> whose <a class="reference external" href="https://docs.google.com/document/d/1KQrBxwaVIPIac_6SCf--w-vZBeHkTvtaqPSU_icIccc/edit#bookmark=kix.k81vs7t5p45i">base
type</a>
is <code class="docutils literal notranslate"><span class="pre">Pᵢ</span></code>, replace <code class="docutils literal notranslate"><span class="pre">V</span></code> with the <a class="reference external" href="#unioning">union</a> of <code class="docutils literal notranslate"><span class="pre">Aᵢ</span></code> and
the <a class="reference external" href="#additional-nullness">additional nullness</a> of <code class="docutils literal notranslate"><span class="pre">V</span></code>.</p>
</div>
<div class="section" id="augmented-null-types">
<span id="null-types"></span><h2>Augmented null types<a class="headerlink" href="#augmented-null-types" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>The JLS refers to “the null type.” In this spec, we assign an
<a class="reference external" href="#additional-nullness">additional nullness</a> to all types, including
the null type. This produces multiple null types:</p>
<ul>
<li><p>the null <a class="reference external" href="https://docs.google.com/document/d/1KQrBxwaVIPIac_6SCf--w-vZBeHkTvtaqPSU_icIccc/edit#bookmark=kix.k81vs7t5p45i">base
type</a>
with additional nullness <code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code>: the “bottom”/“nothing” type
used in <a class="reference external" href="#capture-conversion">capture conversion</a></p>
<blockquote>
<div><p>No value, including <code class="docutils literal notranslate"><span class="pre">null</span></code> itself, has this type.</p>
</div></blockquote>
</li>
<li><p>the null base type with additional nullness <code class="docutils literal notranslate"><span class="pre">UNION_NULL</span></code>: the type
of the null reference</p></li>
<li><p>the null base type with additional nullness
<code class="docutils literal notranslate"><span class="pre">CODE_NOT_NULLNESS_AWARE</span></code></p>
<blockquote>
<div><p>This may be relevant only in implementation code.</p>
</div></blockquote>
</li>
</ul>
</div>
<div class="section" id="the-least-convenient-world-and-the-most-convenient-world">
<span id="multiple-worlds"></span><h2>The least convenient world and the most convenient world<a class="headerlink" href="#the-least-convenient-world-and-the-most-convenient-world" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Some of the rules in this spec come in 2 versions, 1 for “the least
convenient world” and 1 for “the most convenient world.”</p>
<p>Tools may implement either or both versions of the rules.</p>
<blockquote>
<div><p>Our goal is to allow tools and their users to choose their desired
level of strictness in the presence of <code class="docutils literal notranslate"><span class="pre">CODE_NOT_NULLNESS_AWARE</span></code>.
“The least convenient world” usually assumes that types are
incompatible unless it has enough information to prove they are
compatible; “the most convenient world” assumes that types are
compatible unless it has enough information to prove they are
incompatible.</p>
<p>Thus, strict tools may want to implement the least-convenient-world
version of rules, and lenient tools may wish to implement the
most-convenient-world version. Or a tool might implement both and let
users select which rules to apply.</p>
<p>Another possibility is for a tool to implement both versions and to
use that to distinguish between “errors” and “warnings.” Such a tool
might run each check first in the least convenient world and then, if
the check fails, run it again in the most convenient world. If the
check fails in both worlds, the tool would produce an error. If it
passes only because of the most convenient interpretation, the tool
would produce a warning.</p>
</div></blockquote>
<p>The main body of each section describes the <em>least</em>-convenient-world
rule. If the most-convenient-world rule differs, the differences are
explained at the end.</p>
<div class="section" id="propagating-the-most-least-convenient-world">
<span id="propagating-multiple-worlds"></span><h3>Propagating the most/least convenient world<a class="headerlink" href="#propagating-the-most-least-convenient-world" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>When one rule in this spec refers to another, it refers to the rule for
the same “world.” For example, when the rules for
<a class="reference external" href="#containment">containment</a> refer to the rules for
<a class="reference external" href="#subtyping">subtyping</a>, the most-convenient-world containment check
applies the most-convenient-world subtyping check, and the
least-convenient-world containment check applies the
least-convenient-world subtyping check.</p>
<p>This applies even if a rule says it is the same for both worlds: It
means “the same except that any other rules are applied in the
corresponding world.”</p>
</div>
</div>
<div class="section" id="same-type">
<h2>Same type<a class="headerlink" href="#same-type" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">S</span></code> and <code class="docutils literal notranslate"><span class="pre">T</span></code> are the same type if <code class="docutils literal notranslate"><span class="pre">S</span></code> is a <a class="reference external" href="#subtyping">subtype</a>
of <code class="docutils literal notranslate"><span class="pre">T</span></code> and <code class="docutils literal notranslate"><span class="pre">T</span></code> is a subtype of <code class="docutils literal notranslate"><span class="pre">S</span></code>.</p>
</div>
<div class="section" id="subtyping">
<h2>Subtyping<a class="headerlink" href="#subtyping" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">A</span></code> is a subtype of <code class="docutils literal notranslate"><span class="pre">F</span></code> if both of the following conditions are met:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">A</span></code> is a subtype of <code class="docutils literal notranslate"><span class="pre">F</span></code> according to the <a class="reference external" href="#nullness-delegating-subtyping">nullness-delegating
subtyping rules for Java</a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">A</span></code> is a <a class="reference external" href="#nullness-subtyping">nullness subtype</a> of <code class="docutils literal notranslate"><span class="pre">F</span></code>.</p></li>
</ul>
</div>
<div class="section" id="nullness-delegating-subtyping-rules-for-java">
<span id="nullness-delegating-subtyping"></span><h2>Nullness-delegating subtyping rules for Java<a class="headerlink" href="#nullness-delegating-subtyping-rules-for-java" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>The Java subtyping rules are defined in <a class="reference external" href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.10">JLS
4.10</a>.
We add to them as follows:</p>
<ul>
<li><p><a class="reference external" href="#concept-references">As always</a>, interpret the Java rules as
operating on <a class="reference external" href="#augmented-type">augmented types</a>, not <a class="reference external" href="https://docs.google.com/document/d/1KQrBxwaVIPIac_6SCf--w-vZBeHkTvtaqPSU_icIccc/edit#bookmark=kix.k81vs7t5p45i">base
types</a>.
However, when applying the Java direct-supertype rules themselves,
<em>ignore</em> the <a class="reference external" href="#additional-nullness">additional nullness</a> of the
input types and output types. The augmented types matter only when
the Java rules refer to <em>other</em> rules that are defined in this spec.
<em>Those</em> rules respect the additional nullness of some type components
– but never the additional nullness of the type component that
represents the whole input or output type.</p>
<blockquote>
<div><p>To “ignore” the output’s additional nullness, we recommend
outputting a value of <code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code>, since that is valid for all
types, including <a class="reference external" href="#intersection-types">intersection types</a>.</p>
</div></blockquote>
</li>
<li><p>When the Java array rules require one type to be a <em>direct</em> supertype
of another, consider the direct supertypes of <code class="docutils literal notranslate"><span class="pre">T</span></code> to be <em>every</em>
type that <code class="docutils literal notranslate"><span class="pre">T</span></code> is a <a class="reference external" href="#subtyping">subtype</a> of (as always, applying
the definition of subtyping in this spec).</p></li>
</ul>
</div>
<div class="section" id="nullness-subtyping">
<h2>Nullness subtyping<a class="headerlink" href="#nullness-subtyping" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">A</span></code> is a nullness subtype of <code class="docutils literal notranslate"><span class="pre">F</span></code> if any of the following conditions
are met:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">F</span></code> is <a class="reference external" href="#null-inclusive-under-every-parameterization">null-inclusive under every
parameterization</a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">A</span></code> is <a class="reference external" href="#null-exclusive-under-every-parameterization">null-exclusive under every
parameterization</a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">A</span></code> has a <a class="reference external" href="#nullness-subtype-establishing-path">nullness-subtype-establishing
path</a> to any type whose base
type is the same as the base type of <code class="docutils literal notranslate"><span class="pre">F</span></code>.</p></li>
</ul>
<p>Nullness subtyping (and thus subtyping itself) is <em>not</em> transitive.</p>
<p>(Contrast this with our <a class="reference external" href="#nullness-delegating-subtyping">nullness-delegating
subtyping</a> rules and
<a class="reference external" href="#containment">containment</a> rules: Each of those is defined as a
transitive closure. However, technically speaking, <a class="reference external" href="https://groups.google.com/d/msg/jspecify-dev/yPnkx_GSb0Q/hLgS_431AQAJ">there are cases in
which those should not be transitive,
either</a>.
Fortunately, this “mostly transitive” behavior is exactly the behavior
that implementations are likely to produce naturally. Maybe someday we
will find a way to specify this fully correctly.)</p>
</div>
<div class="section" id="null-inclusive-under-every-parameterization">
<h2>Null-inclusive under every parameterization<a class="headerlink" href="#null-inclusive-under-every-parameterization" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>A type is null-inclusive under every parameterization if it meets either
of the following conditions:</p>
<ul class="simple">
<li><p>Its <a class="reference external" href="#additional-nullness">additional nullness</a> is <code class="docutils literal notranslate"><span class="pre">UNION_NULL</span></code>.</p></li>
<li><p>It is an intersection type whose elements all are null-inclusive
under every parameterization.</p></li>
</ul>
<p><strong>Most convenient world:</strong> The rule is the same except that the
requirement for <code class="docutils literal notranslate"><span class="pre">UNION_NULL</span></code> is loosened to “<code class="docutils literal notranslate"><span class="pre">UNION_NULL</span></code> or
<code class="docutils literal notranslate"><span class="pre">CODE_NOT_NULLNESS_AWARE</span></code>.”</p>
</div>
<div class="section" id="null-exclusive-under-every-parameterization">
<h2>Null-exclusive under every parameterization<a class="headerlink" href="#null-exclusive-under-every-parameterization" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>A type is null-exclusive under every parameterization if it has a
<a class="reference external" href="#nullness-subtype-establishing-path">nullness-subtype-establishing
path</a> to any augmented class or
array type.</p>
<blockquote>
<div><p>This rule refers specifically to a “class or array type,” as distinct
from other types like type variables and intersection types.</p>
</div></blockquote>
</div>
<div class="section" id="nullness-subtype-establishing-path">
<h2>Nullness-subtype-establishing path<a class="headerlink" href="#nullness-subtype-establishing-path" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">A</span></code> has a nullness-subtype-establishing path to <code class="docutils literal notranslate"><span class="pre">F</span></code> if both of the
following hold:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">A</span></code> has <a class="reference external" href="#additional-nullness">additional nullness</a>
<code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code>.</p></li>
<li><p>There is a path from <code class="docutils literal notranslate"><span class="pre">A</span></code> to <code class="docutils literal notranslate"><span class="pre">F</span></code> through
<a class="reference external" href="#nullness-subtype-establishing-direct-supertype-edges">nullness-subtype-establishing direct-supertype
edges</a>.</p></li>
</ul>
<p><strong>Most convenient world:</strong> The rules are the same except that the
requirement for <code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code> is loosened to “<code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code> or
<code class="docutils literal notranslate"><span class="pre">CODE_NOT_NULLNESS_AWARE</span></code>.”</p>
</div>
<div class="section" id="nullness-subtype-establishing-direct-supertype-edges">
<h2>Nullness-subtype-establishing direct-supertype edges<a class="headerlink" href="#nullness-subtype-establishing-direct-supertype-edges" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">T</span></code> has nullness-subtype-establishing direct-supertype edges to the
union of the nodes computed by the following 2 rules:</p>
<p>Upper-bound rule:</p>
<ul class="simple">
<li><p>if <code class="docutils literal notranslate"><span class="pre">T</span></code> is an augmented intersection type: all the intersection
type’s elements whose <a class="reference external" href="#additional-nullness">additional nullness</a>
is <code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code></p></li>
<li><p>if <code class="docutils literal notranslate"><span class="pre">T</span></code> is an augmented type variable: all the corresponding type
parameter’s upper bounds whose additional nullness is <code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code></p></li>
<li><p>otherwise: no nodes</p></li>
</ul>
<p>Lower-bound rule:</p>
<ul class="simple">
<li><p>for every type parameter <code class="docutils literal notranslate"><span class="pre">P</span></code> that has a lower bound whose <a class="reference external" href="https://docs.google.com/document/d/1KQrBxwaVIPIac_6SCf--w-vZBeHkTvtaqPSU_icIccc/edit#bookmark=kix.k81vs7t5p45i">base
type</a>
is the same as <code class="docutils literal notranslate"><span class="pre">T</span></code>’s base type and whose additional nullness is
<code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code>: the type variable <code class="docutils literal notranslate"><span class="pre">P</span></code></p></li>
<li><p>otherwise: no nodes</p></li>
</ul>
<p><strong>Most convenient world:</strong> The rules are the same except that the
requirements for <code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code> are loosened to “<code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code> or
<code class="docutils literal notranslate"><span class="pre">CODE_NOT_NULLNESS_AWARE</span></code>.”</p>
</div>
<div class="section" id="containment">
<h2>Containment<a class="headerlink" href="#containment" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>The Java rules are defined in <a class="reference external" href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.5.1">JLS
4.5.1</a>.
We add to them as follows:</p>
<ul>
<li><p>Disregard the 2 rules that refer to a bare <code class="docutils literal notranslate"><span class="pre">?</span></code>. Instead, treat
<code class="docutils literal notranslate"><span class="pre">?</span></code> like <code class="docutils literal notranslate"><span class="pre">?</span> <span class="pre">extends</span> <span class="pre">Object</span></code>, where the <a class="reference external" href="#additional-nullness">additional
nullness</a> of the <code class="docutils literal notranslate"><span class="pre">Object</span></code> bound is
specified by <a class="reference external" href="#unbounded-wildcard">“Bound of an unbounded
wildcard.”</a></p>
<blockquote>
<div><p>This is just a part of our universal rule to treat a bare <code class="docutils literal notranslate"><span class="pre">?</span></code>
like <code class="docutils literal notranslate"><span class="pre">?</span> <span class="pre">extends</span> <span class="pre">Object</span></code>.</p>
</div></blockquote>
</li>
<li><p>The rule written specifically for <code class="docutils literal notranslate"><span class="pre">?</span> <span class="pre">extends</span> <span class="pre">Object</span></code> applies only
if the additional nullness of the <code class="docutils literal notranslate"><span class="pre">Object</span></code> bound is <code class="docutils literal notranslate"><span class="pre">UNION_NULL</span></code>.</p></li>
<li><p>When the JLS refers to the same type <code class="docutils literal notranslate"><span class="pre">T</span></code> on both sides of a rule,
the rule applies if and only if this spec defines the 2 types to be
the <a class="reference external" href="#same-type">same type</a>.</p></li>
</ul>
<p><strong>Most convenient world:</strong> The rules are the same except that the
requirement for <code class="docutils literal notranslate"><span class="pre">UNION_NULL</span></code> is loosened to “<code class="docutils literal notranslate"><span class="pre">UNION_NULL</span></code> or
<code class="docutils literal notranslate"><span class="pre">CODE_NOT_NULLNESS_AWARE</span></code>.”</p>
</div>
<div class="section" id="capture-conversion">
<h2>Capture conversion<a class="headerlink" href="#capture-conversion" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>The Java rules are defined in <a class="reference external" href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-5.html#jls-5.1.10">JLS
5.1.10</a>.
We add to them as follows:</p>
<ul>
<li><p>The output type of the conversion has the same <a class="reference external" href="#additional-nullness">additional
nullness</a> as the input type.</p></li>
<li><p>Disregard the JLS rule about <code class="docutils literal notranslate"><span class="pre">&lt;?&gt;</span></code>. Instead, treat <code class="docutils literal notranslate"><span class="pre">?</span></code> like
<code class="docutils literal notranslate"><span class="pre">?</span> <span class="pre">extends</span> <span class="pre">Object</span></code>, where the <a class="reference external" href="#additional-nullness">additional
nullness</a> of the <code class="docutils literal notranslate"><span class="pre">Object</span></code> bound is
specified by <a class="reference external" href="#unbounded-wildcard">“Bound of an unbounded
wildcard.”</a></p>
<blockquote>
<div><p>This is just a part of our universal rule to treat a bare <code class="docutils literal notranslate"><span class="pre">?</span></code>
like <code class="docutils literal notranslate"><span class="pre">?</span> <span class="pre">extends</span> <span class="pre">Object</span></code>.</p>
</div></blockquote>
</li>
<li><p>When a rule generates a lower bound that is the null type, we specify
that its additional nullness is <code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code>. (See <a class="reference external" href="#null-types">“Augmented null
types.”</a>)</p></li>
</ul>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="index.html" class="btn btn-neutral float-left" title="JSpecify: 静的解析のための標準化されたJavaアノテーション" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2020, The JSpecify Authors.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>